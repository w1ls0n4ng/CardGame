# CardGame
## 1、概述

本文档描述了基于 Cocos2d-x 引擎开发的纸牌小游戏的技术架构、模块设计及功能实现。整个项目的架构遵循了 MVC（模型-视图-控制器）模式，通过分离数据、视图和业务逻辑来提高可维护性和扩展性。以下是对各个目录和模块的详细说明：

## 2、项目结构
```
Classes/
|-- configs/            # 存放静态配置文件
    |-- loaders/        # 配置文件加载器
        |-- LevelConfigLoader.h      # 关卡配置加载器
    |-- models/         # 存放模型文件
        |-- CardResConfig.h  # 卡牌资源配置
        |-- LevelConfig.h    # 关卡配置数据
        |-- Params.h         # 全局参数配置
|-- controllers/        # 控制器：处理游戏逻辑和事件
    |-- GameController.cpp  # 游戏控制器，管理游戏主流程
    |-- GameController.h    # 游戏控制器头文件
    |-- PlayFieldController.cpp  # 牌桌控制器，管理牌桌上的卡牌交互
    |-- PlayFieldController.h    # 牌桌控制器头文件
    |-- StackController.cpp     # 卡牌堆栈控制器
    |-- StackController.h       # 卡牌堆栈控制器头文件
|-- managers/           # 管理器层
    |-- UndoManager.h    # 撤销管理器，记录和恢复操作
|-- models/             # 运行时数据模型
    |-- CardModel.h      # 卡牌模型，管理每张卡的状态
    |-- GameModel.h      # 游戏模型，存储游戏的状态
    |-- UndoModel.h      # 撤销模型，管理撤销数据
|-- services/           # 无状态的业务逻辑服务
    |-- GameModelFromLevelGenerator.cpp  # 关卡生成器，将配置转换为游戏模型
    |-- GameModelFromLevelGenerator.h    # 关卡生成器头文件
    |-- LevelConfigLoader.cpp    # 关卡配置加载器实现
    |-- UndoManager.cpp   # 撤销管理器实现
|-- views/              # 视图层：UI组件
    |-- GameScene.cpp    # 游戏主场景
    |-- GameScene.h      # 游戏主场景头文件
    |-- HelloWorldScene.cpp  # 试验场景
    |-- HelloWorldScene.h    # 试验场景头文件
|-- AppDelegate.cpp     # 应用程序入口
|-- AppDelegate.h       # 应用程序头文件
```

## 3、架构设计
### 模型层（Models）
模型层包含了数据模型和游戏状态管理。我们定义了以下重要的类：
- CardModel：表示卡牌，包含卡牌的花色、点数、位置等信息。它还跟踪是否被其他卡牌覆盖，是否可交互等状态。
- GameModel：表示整个游戏的状态，包括所有卡牌、玩家当前的状态以及游戏进度。
- UndoModel：存储和管理游戏中的撤销操作记录，允许在玩家需要时恢复到先前的游戏状态。

模型层的职责是：
- 存储和管理数据（如卡牌、游戏状态等）。
- 提供接口让控制器层和视图层可以获取和更新数据。

### 控制器层（Controllers）
控制器层负责协调视图层和模型层之间的交互。它将用户的输入映射到相应的业务逻辑，并通过模型更新视图。控制器层包括：
- GameController：管理整个游戏的流程，如游戏开始、结束、回合切换等。
- PlayFieldController：管理牌桌的逻辑，包括卡牌的移动、翻转和交互等。
- StackController：管理卡牌堆栈，包括卡牌的堆叠、移动等。

控制器层的职责是：
- 处理用户输入（例如点击卡牌、移动卡牌）。
- 更新游戏状态和模型数据（例如卡牌的移动、翻转等）。
- 通知视图层更新界面。

### 视图层（Views）
视图层负责展示游戏界面。它从控制器获取数据，并在界面上渲染出来。视图层包括：
- GameScene：游戏的主要场景，显示卡牌、背景和UI控件。
- HelloWorldScene：初始登录场景。

视图层的职责是：
- 负责所有用户界面的显示和交互（如渲染卡牌、按钮等）。
- 获取并展示来自模型的数据。

### 管理器层（Managers）
管理器层提供了全局性功能和服务，专门负责一些跨多个模块的功能。例如：
- UndoManager：负责撤销管理功能，保存撤销记录，处理撤销操作。

管理器层的职责是：
- 提供全局功能（如撤销）。
- 管理一些跨控制器和视图的共享状态。

### 服务层（Services）
服务层包含业务逻辑服务，如：
- GameModelFromLevelGenerator：根据关卡配置生成游戏模型。
- LevelConfigLoader：加载关卡配置文件并解析。

服务层的职责是：
- 处理具体的业务逻辑。
- 提供必要的计算或数据转换功能。

## 4、核心数据结构
CardModel 中两个重要数字字段
```
std::vector<unsigned int> _coveredByIds;    // 记录覆盖该卡牌的卡牌 IDs
std::vector<unsigned int> _coverIds;        // 记录该卡牌覆盖的卡牌 IDs
```
1. **coveredByIds**（记录覆盖当前卡牌的卡牌 IDs）

    这个字段是用来记录哪些卡牌覆盖了当前卡牌，即当前卡牌被哪些卡牌遮住。例如，在你的游戏中，如果卡牌 B 盖住了卡牌 A，那么 A 的 coveredByIds 就会记录 B 的 UID。通过这个字段，你可以判断卡牌是否被遮挡，并且可以控制它是否可以交互。

    作用：判断卡牌是否被遮挡，进而决定它是否可交互（如不可交互的卡牌不能被点击）。

2. **coverIds**（记录当前卡牌覆盖的卡牌 IDs）

    这个字段是用来记录当前卡牌覆盖了哪些卡牌。即卡牌 A 覆盖了卡牌 B，那么 A 的 coverIds 就会记录 B 的 UID。通过这个字段，你可以管理卡牌的覆盖状态，使得卡牌之间的遮挡关系被正确地处理。

    作用：记录当前卡牌覆盖的卡牌，并确保卡牌的状态一致。

具体的一次点击交互步骤：
1. **卡牌被点击：** 当某张卡牌（比如卡牌 X）被点击时，我们需要查看它的 `coveredIds`，即它覆盖了哪些卡牌。
2. **移除 coveredByIds 中的 X：** 遍历每个 `coveredIds` 中的卡牌，从它们的 `coveredByIds` 列表中移除 X 的 ID，以此表示卡牌 X 的覆盖关系已经被解除。
3. **判断是否可选：** 如果移除后，某个卡牌的 `coveredByIds` 为空，说明它没有被其他卡牌覆盖，那么它就可以再次交互（即可以被选中）。

### 5、配置
当前项目中的关卡布局、手牌区尺寸等参数都集中管理于 `params.h` 文件中，若需修改 Level 配置或调整界面尺寸，可直接在该文件中进行更新。此外，代码中还有部分变量（如资源路径、动画参数等）是以硬编码形式存在的，尚未统一提取为配置项。

为了提升项目的灵活性与可维护性，建议后续逐步将这类“潜在可配置项”提取到 `params.h` 或配置文件中统一管理，实现更加清晰的配置体系。



## 6、小结
本项目采用了 MVC 架构（模型-视图-控制器），这使得代码结构更加清晰、模块化，易于维护和扩展。以下是项目架构的几个核心要点：
- 模型层（Model）：负责存储和管理游戏数据，如卡牌的状态、游戏的进度等。
- 视图层（View）：负责显示游戏界面，并通过控制器获取模型的数据来更新界面。
- 控制器层（Controller）：协调模型和视图之间的交互，处理用户输入并更新模型。

通过这种架构，任何新功能的添加或现有功能的扩展都可以基于现有的模块进行修改。例如，新增卡牌交互、撤销功能或更多复杂的动画效果都可以在不破坏现有架构的基础上实现。

扩展建议：
- 增加新的游戏模式或规则：通过修改 GameModel 和相关控制器，扩展不同的游戏玩法或规则。
- 增强动画效果和UI反馈：通过扩展视图层，可以实现更多动态效果（例如卡牌翻转、胜利动画等）。
- 实现多种用户交互方式：比如触摸、拖动等多样的用户输入方式，均可以通过扩展控制器层来实现。

更具体的需求文档可参见 `纸牌程序设计【需求一】.pdf`